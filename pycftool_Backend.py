import numpy as np
from scipy.optimize import curve_fit
from scipy.signal import find_peaks

import pickle
import os

from pycftool_Frontend import *
from pycftool_Fit import *
from pycftool_FitModel import *


class Backend():

    def __init__(self,
                 fit_models,       # List of fit models
                 data_x,           # Data x vector
                 data_y,           # Data y vector
                 fit_class,        # Class of fit result
                 metadata = {      # Dictionary of data metadata
                                'name': 'unnamed_data'     # Must at least contain a name key
                            }
                ):

        self.fit_models = fit_models
        self.model_names = [model.name for model in self.fit_models]

        self.x = data_x
        self.y = data_y
        self.meta = metadata

        self.fit_class = fit_class

        self.fits = []  # Set of fits generated by the backend

        # Data to fit
        self.fit_x = None
        self.fit_y = None

        # The current fit model being used
        self.cur_fitmodel = None

        # Guess for parameters to start fit
        self.param_vect = None

        # Output parameters and covariance matrix from fit attempt
        self.fit_params = None
        self.fit_covmat = None

        # y data for the most recent fit result
        self.fit_result = None


        # Auto fitting mode peaks
        self.peak_idxs = []
        self.peak_search_params_dict = {'height' : 1,
                                        'threshold': 0,
                                        'distance': 20,
                                        'prominence':0.05
                                       }

        self.autofit_window_width = 1

        # Lastly generate the frontend
        self.frontend = Frontend(self)





    def get_data_in_range(self, limits):

        # Determine the indecies for points in the figure viewport
        # The .ravel() method flattens it to a 1-d array
        mask = np.argwhere(np.logical_and(self.x > limits[0], self.x < limits[1])).ravel()

        return self.x[mask], self.y[mask]




    def update_param(self, change):

        # Determine the index of the updated parameter
        index = self.frontend.param_input_widgets.index(change.owner)

        # Update the parameter
        self.param_vect[index] = change.new





    def fit_data(self, change):

        try:

            # Attempt a curve fit
            # This method can often fail if the fit model or initial parameters
            # are very far off. As such it is necessary to enclose in a try statement
            self.fit_params, self.fit_covmat = curve_fit(

                  self.cur_fitmodel.f,                # Fit model function (callable)
                  self.fit_x,                         # x data to fit
                  self.fit_y,                         # y data to fit
                  p0=self.param_vect,                 # Initial guess for fit params
                  bounds=(                            # Parameter bounds
                      self.cur_fitmodel.param_min,        # Parameter lower bound
                      self.cur_fitmodel.param_max         # Parameter upper bound
                  )

            )


            # Compute the updated fit line
            self.fit_result = self.cur_fitmodel.f(self.fit_x, *self.fit_params)

            # Update the front end
            self.frontend.update_results()

        except Exception as e:

            print('Error encountered with fit:\n\t' + str(e))


    def save(self, change):

        try:
            name = 'fit_results_' + str(self.meta['name'] ) + '.p'
        except Exception:
            name = 'fit_results_' + str(self.meta['filename'] ) + '.p'
        except:
            name = 'fit_results.p'

        # Create a dictionary to hold the relevant metadata and results (Fit objects)
        results = {
            'data_x' : self.x,
            'data_y' : self.y,
            'meta'   : self.meta,
            'fits'   : self.fits
        }



        pickle.dump( results, open(name, 'wb') )
        print('Saved results!')

    def delete_fit(self, index):

        fit_to_delete = self.fits.pop(index)

        # Would be good to delete the fit from memory... To do later...


    def find_peaks(self):

        try:
            self.peak_idxs, _ = find_peaks(self.y, **self.peak_search_params_dict)

        except Exception as e:

            print('Error encountered with peak search:\n\t' + str(e))


        if len(self.peak_idxs) > 0:
            return True
        else:
            return False